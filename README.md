# TypeScript
TypeScript

JAVASCRIPT是一门动态弱类型语言，对变量的类型非常宽容，而且不会再这些变量和它们的调用者之间建立结构化的契约，在ES标准推出静态类型检查之前，TypeScript是当下解决此问题的最佳方案。  
## 什么是TypeScript ?  
TypeScript是拥有类型系统的Javascript的超集，  
可以编译成纯Javascript:
+ 类型检查
+ 语言扩展
+ 工具属性
## 为什么要使用TypeScript ?   
使用Typescript的其他好处：   
+ 接口定义代替文档
+ IDE能够提高开发效率，降低维护成本
+ 重塑 ”类型思维“   

在你的脑中种下”类型思维“的种子
+ 思维方式决定了变成习惯
+ 编程习惯奠定了工程质量
+ 工程质量划定了能力边界

## 类型基础
+ 强类型语言与弱类型语言  
+ 静态类型语言与动态类型语言  
+ 其他定义  
+ 小结  

+ 强类型语言与弱类型语言
  + 强类型语言  
    在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容  
    通俗定义：强类型语言不允许改变变量的数据类型，除非进行强制类型转换  
  + 弱类型语言  
    在弱类型语言中，变量可以被赋予不同的数据类型  
+ 静态类型语言与动态类型语言
  + 静态类型语言：在编译阶段确定所有变量的类型
  + 动态类型语言：在执行阶段确定所有变量的类型
  + 静态类型与动态类型对比  
  
  | 静态类型语言 | 动态类型语言 |  
  | --------   | :----: |  
  | 对类型极度严格 | 对类型非常宽松|  
  | 立即发现错误 | Bug可能隐藏数月甚至数年 |  
  | 运行时性能好| 运行时性能差 |  
  | 自文档化| 可读性差 | 
  
  动态类型语言的支持者认为：  
  + 性能是可以改善的（V8引擎），而语言的灵活性更重要 
  + 隐藏的错误可以通过单元测试发现
  + 文档可以通过工具生成

## TypeScript的数据类型
+ Boolean
+ Number
+ String
+ Array
+ Function
+ Object
+ Symbol
+ undefined
+ null
+ void
+ any
+ never
+ 元组
+ 枚举
+ 高级类型

## 类型注释
作用： 相当于强类型语言中的类型声明  
语法： (变量/函数): type  

枚举： 一组有名字的常量集合  
类与接口  
泛型： 不预先确定的数据类型，具体的类型在使用的时候才能确定  
   + 增强程序的可拓展性：函数或类可以轻松地支持多种数据类型
   + 增强代码的可读性: 不必写多条函数重载，或者冗长的联合类型声明
   + 灵活地控制类型之间的约束
   
类型检查机制：  
TypeScript编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。  
作用：辅助开发，提高开发效率  
+ 类型推断  
  不需要指定变量的类型（函数的返回值类型）,typeScript可以根据某些规则自动地为其推断出一个类型。
  + 基础类型推断
  + 最佳通用类型推断
  + 上下文类型推断
+ 类型兼容性  
  当一个类型Y可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y
  + 结构之间兼容： 成员少的兼容成员多的
  + 函数之间兼容： 参数多的兼容参数少的
+ 类型保护  
  TypeScript能够在特定的区块中保证变量属于某种确定的类型  
  可以在此区块中放心地引用此类型的属性，或者调用此类型的方法。  

# 工程篇

awesome-typescript-loader  
与 ts-loader 的主要区别:  
+ 更适合与babel集成，使用Babel的转义和缓存
+ 不需要安装额外的插件，就可以把类型检查放在独立进程中进行
使用TypeScript, 为什么还需要Babel  

|  |编译能力 | 类型检查 | 插件 |  
| --------   | -----:   |-----:   | :----: |
| TSC | ts(x)、js(x) => ES3/5/6/... | 有 |无 |
| Babel | ts(x)、js(x) => ES3/5/6/... | 无 | 有 |

## 如何选择TypeScript 编译工具
+ 如果没有使用过Babel，首选TypeScript 自身的编译器（可配合ts-loader使用）
+ 如果项目中已经使用了Babel，安装@bable/preset-typescript (可配合tsc做类型检查)
+ 两种编译工具不要混用

## TSLint 与 ESLint
TypeScript官方转向ESLint的原因：
+ TSLint执行规则的方式存在一些架构问题，从而影响了性能，而修复这些问题会破坏现有的规则；
+ ESLint的性能更好，并且社区用户通常拥有ESLint的规则配置（比如针对React和Vue的规则）,而不会拥有TSLint的规则配置

TypeScript 类型检查、语言转换 语法错误  
ESLint 代码风格 语法错误  

## TypeScript的工具体系
+ 编译工具： ts-loader、@babel/preset-typescript
+ 代码检查工具: eslint+ typescript-eslint、 babel-eslint
+ 单元测试工具：ts-jest、babel-jest

